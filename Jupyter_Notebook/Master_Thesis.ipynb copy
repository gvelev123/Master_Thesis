{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from numpy.random import seed\n",
    "from tensorflow.random import set_seed\n",
    "\n",
    "import keras\n",
    "import io\n",
    "print(keras.__version__)\n",
    "import tensorflow\n",
    "print(tensorflow.__version__)\n",
    "import pandas_datareader\n",
    "import time\n",
    "#import talib\n",
    "import requests\n",
    "import pandas as pd\n",
    "import requests\n",
    "import pandas_datareader.data as web\n",
    "import numpy as np\n",
    "from keras.layers import Flatten, Conv2D, Input, Conv1D, LeakyReLU, PReLU\n",
    "from datetime import timedelta\n",
    "from datetime import datetime\n",
    "import numpy as np\n",
    "\n",
    "from keras import optimizers\n",
    "from keras.wrappers.scikit_learn import KerasClassifier\n",
    "from keras.models import Sequential\n",
    "from keras.models import Model\n",
    "from keras.layers import Dense, Dropout, Activation, Flatten, Input, Bidirectional, RepeatVector, TimeDistributed\n",
    "from keras.utils import np_utils\n",
    "from keras.callbacks import EarlyStopping\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.model_selection import train_test_split\n",
    "from keras.layers import LSTM\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from datetime import datetime"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Classes/Functions used for NAS:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.1. Class for RNN Cell (custom Layer) constructed as a Tree:\n",
    "\n",
    "- The implementation follows the one of LSTM-s (https://github.com/keras-team/keras/blob/master/keras/layers/recurrent.py)\n",
    "\n",
    "- **The Init-Method**: initialized all relevant attributes in the class\n",
    "\n",
    "- **The Build-Method**: initializes the weights for the current state, hidden state and the biases\n",
    "\n",
    "- **The Call-Method**: \n",
    "        - computes the output of each node in the RNN-Tree-Cell\n",
    "        - returns the output of the final node as the new hidden state\n",
    "        - as well as: the new cell state based on a pre-specified index (set in the Init-Method)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#ACCORDING TO PAPER: https://arxiv.org/pdf/1611.01578.pdf\n",
    "## import tensorflow as tf\n",
    "import numpy as np\n",
    "\n",
    "import keras\n",
    "\n",
    "from keras import backend as K\n",
    "#tf.keras.backend.clear_session()\n",
    "import sys\n",
    "import traceback\n",
    "from keras.layers import RNN\n",
    "from keras.models import Model\n",
    "from keras import activations, initializers,regularizers, constraints\n",
    "import tensorflow as tf\n",
    "\n",
    "class Custom_RNNCell_tree(keras.layers.Layer):\n",
    "    def __init__(self, units,\n",
    "                 base,\n",
    "                 #Leaf Nodes:\n",
    "                 activations_leaf_nodes,\n",
    "                 actions_leaf_nodes,\n",
    "                 #Cell Inject:\n",
    "                 index_cell_inject,\n",
    "                 action_cell_inject,\n",
    "                 activation_cell_inject,\n",
    "                 #New Cell State:\n",
    "                 index_new_cell_state,\n",
    "                 #Intermediate Levels (Internal Nodes):\n",
    "                 index_intermediate_levels,\n",
    "                 activations_intermediate_levels,\n",
    "                 actions_intermediate_levels,\n",
    "                 #Final Node:\n",
    "                 index_last_node,\n",
    "                 activation_last_node,\n",
    "                 action_last_node,\n",
    "                 #Biases Condition:\n",
    "                 use_bias=True,\n",
    "                 #Initializers:\n",
    "                 kernel_initializer='glorot_uniform',\n",
    "                 recurrent_initializer='orthogonal',\n",
    "                 bias_initializer='zeros',\n",
    "                 #Regularizers:\n",
    "                 kernel_regularizer=None,\n",
    "                 recurrent_regularizer=None,\n",
    "                 bias_regularizer=None,\n",
    "                 #Constant Constraints:\n",
    "                 kernel_constraint=None,\n",
    "                 recurrent_constraint=None,\n",
    "                 bias_constraint=None,\n",
    "                 #Dropout Constraints:\n",
    "                 dropout=0.,\n",
    "                 recurrent_dropout=0,**kwargs):\n",
    "        \n",
    "        self.units = units\n",
    "        self.state_size =(self.units, self.units)\n",
    "        self.output_size = self.units\n",
    "        self.base=base\n",
    "        \n",
    "        #Leaf Nodes:\n",
    "        self.activations_leaf_nodes=activations_leaf_nodes\n",
    "        self.actions_leaf_nodes=actions_leaf_nodes\n",
    "        \n",
    "        #Cell Inject:\n",
    "        self.index_cell_inject=index_cell_inject\n",
    "        self.action_cell_inject=action_cell_inject\n",
    "        self.activation_cell_inject=activation_cell_inject\n",
    "        \n",
    "        #New Cell State:\n",
    "        self.index_new_cell_state=index_new_cell_state\n",
    "        \n",
    "        #Intermediate Nodes:\n",
    "        self.index_intermediate_levels=index_intermediate_levels\n",
    "        self.activations_intermediate_levels=activations_intermediate_levels\n",
    "        self.actions_intermediate_levels=actions_intermediate_levels\n",
    "        \n",
    "        #Final Node:\n",
    "        self.index_last_node=index_last_node\n",
    "        self.activation_last_node=activation_last_node\n",
    "        self.action_last_node=action_last_node\n",
    "        \n",
    "        #Biases:\n",
    "        self.use_bias = use_bias\n",
    "\n",
    "        #Weights Initializer:\n",
    "        self.kernel_initializer = initializers.get(kernel_initializer)\n",
    "        self.recurrent_initializer = initializers.get(recurrent_initializer)\n",
    "        self.bias_initializer = initializers.get(bias_initializer)\n",
    "        \n",
    "        #Weights Regularizer:\n",
    "        self.kernel_regularizer = regularizers.get(kernel_regularizer)\n",
    "        self.recurrent_regularizer = regularizers.get(recurrent_regularizer)\n",
    "        self.bias_regularizer = regularizers.get(bias_regularizer)\n",
    "        \n",
    "        #Weights Constant Constraints:\n",
    "        self.kernel_constraint = constraints.get(kernel_constraint)\n",
    "        self.recurrent_constraint = constraints.get(recurrent_constraint)\n",
    "        self.bias_constraint = constraints.get(bias_constraint)\n",
    "\n",
    "        #Dropout Constraints:\n",
    "        self.dropout = min(1., max(0., dropout))\n",
    "        self.recurrent_dropout = min(1., max(0., recurrent_dropout))\n",
    "        \n",
    "        self._dropout_mask = None\n",
    "        self._recurrent_dropout_mask = None\n",
    "        super(Custom_RNNCell_tree, self).__init__(**kwargs)\n",
    "        \n",
    "        \n",
    "    def build(self, input_shape):\n",
    "        \n",
    "        #1. INPUTS:#############################################################################\n",
    "        #1.1. KERNEL INPUTS/ WEIGHTS FOR INPUTS:\n",
    "        self.kernel_current_input = self.add_weight(shape=(input_shape[-1], self.units*self.base),\n",
    "                                              initializer=self.kernel_initializer,#\"glorot_uniform\",#'uniform',\n",
    "                                              regularizer=self.kernel_regularizer,\n",
    "                                              name='kernel')\n",
    "        #print(\"Initialized Weights First Node (For Inputs): \")\n",
    "        #print(K.eval(self.kernel_current_input))\n",
    "        \n",
    "        #1.2. BIAS WEIGHTS FOR INPUTS:\n",
    "        if self.use_bias:\n",
    "            self.bias = self.add_weight(shape=(self.units*self.base,),\n",
    "                                        name='bias_inputs',\n",
    "                                        initializer=self.bias_initializer,\n",
    "                                        regularizer=self.bias_regularizer,\n",
    "                                        constraint=self.bias_constraint)\n",
    "        else:\n",
    "            self.bias = None\n",
    "        #########################################################################################\n",
    "        \n",
    "        #2. RECURRENT STATE: ####################################################################\n",
    "        #2.1. RECURRENT KERNEL / WEIGHTS FOR PREVIOUS HIDDEN STATE:\n",
    "        self.kernel_previous_hidden = self.add_weight(\n",
    "                    shape=(self.units, self.units*self.base),\n",
    "                    initializer=self.recurrent_initializer,#\"glorot_uniform\",#'uniform',\n",
    "                    regularizer=self.recurrent_regularizer,\n",
    "                    name='recurrent_kernel')\n",
    "        #print(\"Initialized Weights Recurrent Sate:\")\n",
    "        #print(K.eval(self.kernel_previous_hidden))\n",
    "        ########################################################################################\n",
    "        \n",
    "        #kernel_list=[]\n",
    "        \n",
    "        #Input Weights for each of the leaf nodes: \n",
    "        self.kernel_0 = self.kernel_current_input[:, :self.units]\n",
    "        self.kernel_1 = self.kernel_current_input[:, self.units: self.units * 2]\n",
    "        self.kernel_2 = self.kernel_current_input[:, self.units * 2: self.units * 3]\n",
    "        self.kernel_3 = self.kernel_current_input[:, self.units * 3: self.units * 4]\n",
    "        self.kernel_4 = self.kernel_current_input[:, self.units * 4: self.units * 5]\n",
    "        self.kernel_5 = self.kernel_current_input[:, self.units * 5: self.units * 6]\n",
    "        self.kernel_6 = self.kernel_current_input[:, self.units * 6: self.units * 7]\n",
    "        self.kernel_7 = self.kernel_current_input[:, self.units * 7:]\n",
    "        \n",
    "        #recurrent_kernel_list=[]\n",
    "        \n",
    "        #Recurrent Weights for each of the leaf nodes: \n",
    "        self.recurrent_kernel_0 = self.kernel_previous_hidden[:, :self.units]\n",
    "        self.recurrent_kernel_1 = self.kernel_previous_hidden[:, self.units: self.units * 2]\n",
    "        self.recurrent_kernel_2 = self.kernel_previous_hidden[:, self.units * 2: self.units * 3]\n",
    "        self.recurrent_kernel_3 = self.kernel_previous_hidden[:, self.units * 3: self.units * 4]\n",
    "        self.recurrent_kernel_4 = self.kernel_previous_hidden[:, self.units * 4: self.units * 5]\n",
    "        self.recurrent_kernel_5 = self.kernel_previous_hidden[:, self.units * 5: self.units * 6]\n",
    "        self.recurrent_kernel_6 = self.kernel_previous_hidden[:, self.units * 6: self.units * 7]\n",
    "        self.recurrent_kernel_7 = self.kernel_previous_hidden[:, self.units * 7:]\n",
    "        \n",
    "        #if self.use_bias:\n",
    "        #     bias_list=[]\n",
    "        \n",
    "        #Biases:\n",
    "        if self.use_bias:\n",
    "            self.bias_0 = self.bias[:self.units]\n",
    "            self.bias_1 = self.bias[self.units: self.units * 2]\n",
    "            self.bias_2 = self.bias[self.units * 2: self.units * 3]\n",
    "            self.bias_3 = self.bias[self.units * 3: self.units * 4]\n",
    "            self.bias_4 = self.bias[self.units * 4: self.units * 5]\n",
    "            self.bias_5 = self.bias[self.units * 5: self.units * 6]\n",
    "            self.bias_6 = self.bias[self.units * 6: self.units * 7]\n",
    "            self.bias_7 = self.bias[self.units * 7: ]\n",
    "        else:\n",
    "            self.bias_0 = None\n",
    "            self.bias_1 = None\n",
    "            self.bias_2 = None\n",
    "            self.bias_3 = None\n",
    "            self.bias_4 = None\n",
    "            self.bias_5 = None\n",
    "            self.bias_6 = None\n",
    "            self.bias_7 = None\n",
    "            \n",
    "        \n",
    "           \n",
    "        #self.built = True\n",
    "        super(Custom_RNNCell_tree, self).build(input_shape)\n",
    "        \n",
    "        \n",
    "    def call(self, inputs, states, training=None):\n",
    "        #GET THE STATES:\n",
    "        prev_output = states[0]\n",
    "        prev_cell_state=states[1]\n",
    "        \n",
    "        #START LEAF NODES: ##################################################################################\n",
    "        if 0 < self.dropout < 1 and self._dropout_mask is None:\n",
    "            self._dropout_mask = _generate_dropout_mask(\n",
    "                K.ones_like(inputs),\n",
    "                self.dropout,\n",
    "                training=training,\n",
    "                count=self.base)\n",
    "            \n",
    "        if (0 < self.recurrent_dropout < 1 and\n",
    "                self._recurrent_dropout_mask is None):\n",
    "            self._recurrent_dropout_mask = _generate_dropout_mask(\n",
    "                K.ones_like(prev_output),\n",
    "                self.recurrent_dropout,\n",
    "                training=training,\n",
    "                count=self.base)\n",
    "        \n",
    "\n",
    "        dp_mask = self._dropout_mask\n",
    "        rec_dp_mask = self._recurrent_dropout_mask\n",
    "        \n",
    "        \n",
    "        #INPUTS:\n",
    "        if 0 < self.dropout < 1.:\n",
    "                inputs_0 = inputs * dp_mask[0]\n",
    "                inputs_1 = inputs * dp_mask[1]\n",
    "                inputs_2 = inputs * dp_mask[2]\n",
    "                inputs_3 = inputs * dp_mask[3]\n",
    "                inputs_4 = inputs * dp_mask[4]\n",
    "                inputs_5 = inputs * dp_mask[5]\n",
    "                inputs_6 = inputs * dp_mask[6]\n",
    "                inputs_7 = inputs * dp_mask[7]\n",
    "        else:\n",
    "                inputs_0 = inputs \n",
    "                inputs_1 = inputs\n",
    "                inputs_2 = inputs \n",
    "                inputs_3 = inputs \n",
    "                inputs_4 = inputs \n",
    "                inputs_5 = inputs \n",
    "                inputs_6 = inputs\n",
    "                inputs_7 = inputs \n",
    "        #WEIGHTS MATRIX MULTIPLICATION INPUTS:\n",
    "        mm_iputs_0 = K.dot(inputs_0, self.kernel_0)\n",
    "        mm_iputs_1 = K.dot(inputs_1, self.kernel_1)\n",
    "        mm_iputs_2 = K.dot(inputs_2, self.kernel_2)\n",
    "        mm_iputs_3 = K.dot(inputs_3, self.kernel_3)\n",
    "        mm_iputs_4 = K.dot(inputs_4, self.kernel_4)\n",
    "        mm_iputs_5 = K.dot(inputs_5, self.kernel_5)\n",
    "        mm_iputs_6 = K.dot(inputs_6, self.kernel_6)\n",
    "        mm_iputs_7 = K.dot(inputs_7, self.kernel_7)\n",
    "        \n",
    "        \n",
    "        \n",
    "        #ADDING BIAS TO MM INPUTS:\n",
    "        if self.use_bias:\n",
    "                mm_iputs_0 = K.bias_add(mm_iputs_0, self.bias_0)\n",
    "                mm_iputs_1 = K.bias_add(mm_iputs_1, self.bias_1)\n",
    "                mm_iputs_2 = K.bias_add(mm_iputs_2, self.bias_2)\n",
    "                mm_iputs_3 = K.bias_add(mm_iputs_3, self.bias_3)\n",
    "                mm_iputs_4 = K.bias_add(mm_iputs_4, self.bias_4)\n",
    "                mm_iputs_5 = K.bias_add(mm_iputs_5, self.bias_5)\n",
    "                mm_iputs_6 = K.bias_add(mm_iputs_6, self.bias_6)\n",
    "                mm_iputs_7 = K.bias_add(mm_iputs_7, self.bias_7)\n",
    "        \n",
    "        #SAVE OUTPUT FROM WEIGHTS-MM INPUTS IN A LIST:\n",
    "        mm_inputs_array=[mm_iputs_0,mm_iputs_1,mm_iputs_2,\n",
    "                        mm_iputs_3,mm_iputs_4,mm_iputs_5,\n",
    "                        mm_iputs_6,mm_iputs_7]\n",
    "                \n",
    "        #HIDDEN STATE:\n",
    "        if 0 < self.recurrent_dropout < 1.:\n",
    "                prev_output_0 = prev_output * rec_dp_mask[0]\n",
    "                prev_output_1 = prev_output * rec_dp_mask[1]\n",
    "                prev_output_2 = prev_output * rec_dp_mask[2]\n",
    "                prev_output_3 = prev_output * rec_dp_mask[3]\n",
    "                prev_output_4 = prev_output * rec_dp_mask[4]\n",
    "                prev_output_5 = prev_output * rec_dp_mask[5]\n",
    "                prev_output_6 = prev_output * rec_dp_mask[6]\n",
    "                prev_output_7 = prev_output * rec_dp_mask[7]\n",
    "        else:\n",
    "            prev_output_0 = prev_output\n",
    "            prev_output_1 = prev_output \n",
    "            prev_output_2 = prev_output \n",
    "            prev_output_3 = prev_output \n",
    "            prev_output_4 = prev_output \n",
    "            prev_output_5 = prev_output \n",
    "            prev_output_6 = prev_output \n",
    "            prev_output_7 = prev_output\n",
    "            \n",
    "        #WEIGHTS MATRIX MULTIPLICATION HIDDEN STATE:\n",
    "        mm_previous_output_0=K.dot(prev_output_0, self.recurrent_kernel_0)\n",
    "        mm_previous_output_1=K.dot(prev_output_1, self.recurrent_kernel_1)\n",
    "        mm_previous_output_2=K.dot(prev_output_2, self.recurrent_kernel_2)\n",
    "        mm_previous_output_3=K.dot(prev_output_3, self.recurrent_kernel_3)\n",
    "        mm_previous_output_4=K.dot(prev_output_4, self.recurrent_kernel_4)\n",
    "        mm_previous_output_5=K.dot(prev_output_5, self.recurrent_kernel_5)\n",
    "        mm_previous_output_6=K.dot(prev_output_6, self.recurrent_kernel_6)\n",
    "        mm_previous_output_7=K.dot(prev_output_7, self.recurrent_kernel_7)\n",
    "        \n",
    "        #SAVE OUTPUT FROM WEIGHTS-MM HIDDEN STATE IN A LIST:\n",
    "        mm_previous_output_array=[mm_previous_output_0,mm_previous_output_1,mm_previous_output_2,\n",
    "                                 mm_previous_output_3,mm_previous_output_4,mm_previous_output_5,\n",
    "                                 mm_previous_output_6,mm_previous_output_7]\n",
    "        \n",
    "        outputs_before_activation=[]\n",
    "        outputs_after_activation=[]\n",
    "        #OUTPUTS LEAF NODES:\n",
    "        for i in range(0,len(mm_inputs_array)):\n",
    "            if self.actions_leaf_nodes[i]==\"add\":\n",
    "                output_before_activation=mm_inputs_array[i]+mm_previous_output_array[i]\n",
    "            else:\n",
    "                output_before_activation=mm_inputs_array[i]*mm_previous_output_array[i]\n",
    "            outputs_before_activation.append(output_before_activation)\n",
    "            \n",
    "            output_after_activation=activations.get(self.activations_leaf_nodes[i])(output_before_activation)\n",
    "            outputs_after_activation.append(output_after_activation)\n",
    "            \n",
    "            #CHECK IF INDEX_CELL_INJECT WITHIN ALREADY ADDED OUTPUTS FROM LEAF NODES:\n",
    "            check_index_leafs=len(outputs_after_activation)-1\n",
    "            if self.index_cell_inject==check_index_leafs:\n",
    "                relevant_output=outputs_after_activation[check_index_leafs]\n",
    "                if self.action_cell_inject==\"add\":\n",
    "                    output_cell_inject_before_activation=relevant_output+prev_cell_state\n",
    "                else:\n",
    "                    output_cell_inject_before_activation=relevant_output*prev_cell_state\n",
    "                \n",
    "                #Overwrite outputs before activation:\n",
    "                outputs_before_activation[check_index_leafs]=output_cell_inject_before_activation\n",
    "                \n",
    "                output_cell_inject_after_activation=activations.get(self.activation_cell_inject)(output_cell_inject_before_activation)\n",
    "                #Overwrite the saved output in the list outputs_after_activation:\n",
    "                outputs_after_activation[check_index_leafs]=output_cell_inject_after_activation\n",
    "                \n",
    "        #DONE WITH LEAF NODES##################################################################################\n",
    "        \n",
    "        \n",
    "        #START INTERMEDIATE LEVEL NODES: INTERNAL NODES:#############################################################\n",
    "        for i in range(0,len(self.index_intermediate_levels)):\n",
    "            #Get each pair of indexes:\n",
    "            indexes_intermediate_level=self.index_intermediate_levels[i]\n",
    "            #Split the pair in first and second part indexes:\n",
    "            indexes_first=indexes_intermediate_level[0]\n",
    "            indexes_second=indexes_intermediate_level[1]\n",
    "            #Get the corresponding outputs from the list with outputs after applying the activation:\n",
    "            output_first_part=outputs_after_activation[indexes_first]\n",
    "            output_second_part=outputs_after_activation[indexes_second]\n",
    "            \n",
    "            #Perform the corresponding action: add or elemwise multiplication:\n",
    "            if self.actions_intermediate_levels[i]==\"add\":\n",
    "                output_intermediate_before_activation=output_first_part+output_second_part\n",
    "            else:\n",
    "                output_intermediate_before_activation=output_first_part*output_second_part\n",
    "            \n",
    "            #Append the output before applying the activation function:\n",
    "            outputs_before_activation.append(output_intermediate_before_activation)\n",
    "            \n",
    "            #Apply the activation function and save the output in the corresponding list:\n",
    "            output_intermediate_after_activation=activations.get(self.activations_intermediate_levels[i])(output_intermediate_before_activation)\n",
    "            outputs_after_activation.append(output_intermediate_after_activation)\n",
    "            \n",
    "            #CHECK IF INDEX_CELL_INJECT WITHIN ALREADY ADDED OUTPUTS FROM LEAF NODES:\n",
    "            check_index_intermediate=len(outputs_after_activation)-1\n",
    "            if self.index_cell_inject==check_index_intermediate:\n",
    "                #(redundant code:)\n",
    "                relevant_output=outputs_after_activation[check_index_intermediate]\n",
    "                if self.action_cell_inject==\"add\":\n",
    "                    output_cell_inject_before_activation=relevant_output+prev_cell_state\n",
    "                else:\n",
    "                    output_cell_inject_before_activation=relevant_output*prev_cell_state\n",
    "                \n",
    "                #Overwrite Outputs before Activation:\n",
    "                outputs_before_activation[check_index_intermediate]=output_cell_inject_before_activation\n",
    "                \n",
    "                output_cell_inject_after_activation=activations.get(self.activation_cell_inject)(output_cell_inject_before_activation)\n",
    "                #Overwrite the saved output in the list outputs_after_activation:\n",
    "                outputs_after_activation[check_index_intermediate]=output_cell_inject_after_activation\n",
    "        #DONE WITH INTERMEDIATE LEVEL NODES: ###############################################################\n",
    "        \n",
    "        \n",
    "        #START FINAL NODE: #################################################################################\n",
    "        #Get last and pre-last index from array with outputs after activations:\n",
    "        last_index=len(outputs_after_activation)-1\n",
    "        pre_last_index=len(outputs_after_activation)-2\n",
    "        #Get the corresponding outputs:\n",
    "        last_output=outputs_after_activation[last_index]\n",
    "        pre_last_output=outputs_after_activation[pre_last_index]\n",
    "        \n",
    "        #Perform the final action:\n",
    "        if self.action_last_node==\"add\":\n",
    "            output_final_before_activation=last_output+pre_last_output\n",
    "        else:\n",
    "            output_final_before_activation=last_output*pre_last_output\n",
    "        \n",
    "        #Append the final output before activation:\n",
    "        outputs_before_activation.append(output_final_before_activation)\n",
    "        \n",
    "        #Apply activation and save the final output in the corresponding list:\n",
    "        output_final_after_activation=activations.get(self.activation_last_node)(output_final_before_activation)\n",
    "        outputs_after_activation.append(output_final_after_activation)\n",
    "        \n",
    "        ##CHECK IF INDEX_CELL_INJECT EQUAL TO FINAL NODE INDEX:\n",
    "        check_index_last=len(outputs_after_activation)-1\n",
    "        if self.index_cell_inject==check_index_last:\n",
    "            relevant_output=outputs_after_activation[check_index_last]\n",
    "            if self.action_cell_inject==\"add\":\n",
    "                output_cell_inject_before_activation=relevant_output+prev_cell_state\n",
    "            else:\n",
    "                output_cell_inject_before_activation=relevant_output*prev_cell_state\n",
    "            \n",
    "            #Overwrite Outputs before activation:\n",
    "            outputs_before_activation[check_index_last]=output_cell_inject_before_activation\n",
    "            \n",
    "            \n",
    "            output_cell_inject_after_activation=activations.get(self.activation_cell_inject)(output_cell_inject_before_activation)\n",
    "            #Overwrite the saved output in the list outputs_after_activation:\n",
    "            outputs_after_activation[check_index_last]=output_cell_inject_after_activation\n",
    "        #DONE WITH FINAL NODE: ##############################################################################\n",
    "         \n",
    "        #Get the new cell state:\n",
    "        new_cell_state=outputs_before_activation[self.index_new_cell_state]\n",
    "        \n",
    "        #Get new hidden state: final output:\n",
    "        new_hidden_state=outputs_after_activation[len(outputs_after_activation)-1]\n",
    "        \n",
    "        \n",
    "        # Properly set learning phase on output tensor.\n",
    "        if 0 < self.dropout + self.recurrent_dropout:\n",
    "            if training is None:\n",
    "                new_hidden_state._uses_learning_phase = True\n",
    "        return new_hidden_state,[new_hidden_state,new_cell_state]\n",
    "        \n",
    "def _generate_dropout_mask(ones, rate, training=None, count=1):\n",
    "    def dropped_inputs():\n",
    "        return K.dropout(ones, rate)\n",
    "\n",
    "    if count > 1:\n",
    "        return [K.in_train_phase(\n",
    "            dropped_inputs,\n",
    "            ones,\n",
    "            training=training) for _ in range(count)]\n",
    "    return K.in_train_phase(\n",
    "        dropped_inputs,\n",
    "        ones,\n",
    "        training=training)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.2. Objective Functions for Sampling Hyperparameters with Optuna:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.2.1. Objective Function for RNN-Cell structured as a Tree:\n",
    "- **Samples the Architecture of the RNN-Cell in the following way**:\n",
    "        - for each of the 8 leaf nodes in the RNN-Cell: \n",
    "          samples an action for the current & hidden state (addition or elemntwise multiplication)\n",
    "          and an activation function from {tanh, relu, sigmoid, linear} which is applied after the \n",
    "          action is performed \n",
    "          \n",
    "        - for the intermediate nodes: \n",
    "          samples a combination of the indexes of the nodes from the previous level,\n",
    "          an action & an activation function\n",
    "          \n",
    "        - for injecting the previous cell state:\n",
    "          samples an index in the tree, an action and an activation function\n",
    "          \n",
    "        - for the new cell state:\n",
    "          samples an index in the tree\n",
    "- **Samples further Hyperparameters relevant for the Performance of the RNN**:\n",
    "        - number of neurons for each of the custom RNN layers (2 layers used)\n",
    "        \n",
    "        - dropout rate  for a Dropout-Layer after each of the custom RNN layers\n",
    "        \n",
    "        - weights regularization: type and decay\n",
    "        \n",
    "        - epochs\n",
    "        \n",
    "        - batch size\n",
    "        \n",
    "        - window-size: the number of timesteps in each sequence\n",
    "        \n",
    "        - learning rate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import optuna\n",
    "### import extra_keras_metrics\n",
    "def objective_RNN_Tree(trial):  \n",
    "    seed(123)\n",
    "    set_seed(123)\n",
    "    \n",
    "    print(\"SUMMARY CURRENT TRIAL: \"+\"\\n\")\n",
    "    \n",
    "    print(\"1. CUSTOM RNN-CELL HYPERPARAMETERS:\"+\"\\n\")\n",
    "    n_base=8\n",
    "    #1. FIRST LEVEL: LEAF NODES WITH INDEX (BOTTOM-UP) ################################################\n",
    "    activations=[]\n",
    "    actions=[]\n",
    "    \n",
    "    for i in range(0,n_base):\n",
    "        activation=trial.suggest_categorical('activation_tree_index_{}'.format(i), \n",
    "                                             [\"relu\",\"tanh\",\"sigmoid\",\"linear\"])\n",
    "        action=trial.suggest_categorical('action_tree_index_{}'.format(i), [\"add\",\"elem_multi\"])\n",
    "        activations.append(activation)\n",
    "        actions.append(action)\n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    \n",
    "    #2. SECOND LEVEL: ##################################################################################\n",
    "    #2.1. CHOOSE HOW MANY TIMES TO SAMPLE:\n",
    "    keep_sampling=True\n",
    "    \n",
    "    indexes_to_sample=list(range(n_base))\n",
    "    all_indexes_tree=list(range(n_base))\n",
    "    print(\"  - Sample Index Combinations from: \",indexes_to_sample)\n",
    "    \n",
    "    track_excluded=\"excludeFromNodes_\"\n",
    "        \n",
    "    while keep_sampling:\n",
    "        #Start with the first available index in remaining list indexes_to_sample:\n",
    "        first_index=indexes_to_sample[0]\n",
    "        print(\"  - First Index: \",first_index)\n",
    "        indexes_to_sample.remove(first_index)\n",
    "        track_excluded=track_excluded.split(\"_\")[0]\n",
    "        track_excluded=track_excluded+\"_\"+str(indexes_to_sample)\n",
    "        \n",
    "        second_index=trial.suggest_categorical(track_excluded, indexes_to_sample)\n",
    "        print(\"  - Second Index: \",second_index)\n",
    "        indexes_to_sample.remove(second_index)\n",
    "        all_indexes_tree.append([first_index,second_index])\n",
    "        activation=trial.suggest_categorical('activation_tree_index_{}'.format(len(all_indexes_tree)-1), [\"relu\",\"tanh\",\"sigmoid\",\"linear\"])\n",
    "        action=trial.suggest_categorical('action_tree_index_{}'.format(len(all_indexes_tree)-1), [\"add\",\"elem_multi\"])\n",
    "        activations.append(activation)\n",
    "        actions.append(action)\n",
    "        print(\"  - Remaining Indexes in list: \",indexes_to_sample)\n",
    "        print(\"  - All Indexes so far: \",all_indexes_tree)\n",
    "        print(\"\")\n",
    "        \n",
    "        if len(indexes_to_sample)<=2:\n",
    "            if len(indexes_to_sample)>0:\n",
    "                all_indexes_tree.append(indexes_to_sample)\n",
    "                activation=trial.suggest_categorical('activation_tree_index_{}'.format(len(all_indexes_tree)-1), [\"relu\",\"tanh\",\"sigmoid\",\"linear\"])\n",
    "                action=trial.suggest_categorical('action_tree_index_{}'.format(len(all_indexes_tree)-1), [\"add\",\"elem_multi\"])\n",
    "                activations.append(activation)\n",
    "                actions.append(action)\n",
    "            else:\n",
    "                print(\"Array with Indexes empy!\")\n",
    "            print(\"  - All Indexes so far: \",all_indexes_tree)\n",
    "            print(\"\")\n",
    "            keep_sampling=False   \n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    #THIRD & FOURTH LEVEL: ###############################################################\n",
    "    #Chose combination for third level tree indexes/ second level internal nodes:\n",
    "    indexes_internal_nodes=list(range(len(all_indexes_tree)))[n_base:]\n",
    "    \n",
    "    #THIRD LEVEL:\n",
    "    first_index=indexes_internal_nodes[0]\n",
    "    print(\"  - First Index: \",first_index)\n",
    "    indexes_internal_nodes.remove(first_index)\n",
    "    second_index=trial.suggest_categorical(\"excludeFromNodes_\"+str(indexes_internal_nodes), indexes_internal_nodes)\n",
    "    print(\"  - Second Index: \",second_index)\n",
    "            \n",
    "    indexes_internal_nodes.remove(second_index)        \n",
    "    all_indexes_tree.append([first_index,second_index])\n",
    "    activation=trial.suggest_categorical('activation_tree_index_'+str(len(all_indexes_tree)-1),\n",
    "                                             [\"relu\",\"tanh\",\"sigmoid\",\"linear\"])\n",
    "    action=trial.suggest_categorical('action_tree_index_'+str(len(all_indexes_tree)-1),\n",
    "                                         [\"add\",\"elem_multi\"])\n",
    "    activations.append(activation)\n",
    "    actions.append(action)\n",
    "\n",
    "    all_indexes_tree.append(indexes_internal_nodes)\n",
    "    activation=trial.suggest_categorical('activation_tree_index_'+str(len(all_indexes_tree)-1),\n",
    "                                             [\"relu\",\"tanh\",\"sigmoid\",\"linear\"])\n",
    "    action=trial.suggest_categorical('action_tree_index_'+str(len(all_indexes_tree)-1),\n",
    "                                         [\"add\",\"elem_multi\"])\n",
    "    activations.append(activation)\n",
    "    actions.append(action)\n",
    "    print(\"  - Remaining Indexes in internal Nodes: \",indexes_internal_nodes)\n",
    "    print(\"  - All Indexes so far: \",all_indexes_tree)\n",
    "            \n",
    "    print(\"\")\n",
    "\n",
    "    #FOURTH/FINAL LEVEL:\n",
    "    fourth_level_first_index=len(all_indexes_tree)-1\n",
    "    fourth_level_second_index=len(all_indexes_tree)-2\n",
    "    all_indexes_tree.append([fourth_level_first_index,fourth_level_second_index])\n",
    "        \n",
    "    activation=trial.suggest_categorical('activation_tree_index_'+str(len(all_indexes_tree)-1),\n",
    "                                             [\"relu\",\"tanh\",\"sigmoid\",\"linear\"])\n",
    "    action=trial.suggest_categorical('action_tree_index_'+str(len(all_indexes_tree)-1),\n",
    "                                         [\"add\",\"elem_multi\"])\n",
    "    activations.append(activation)\n",
    "    actions.append(action)\n",
    "    print(\"  - First Index: \",fourth_level_first_index)\n",
    "    print(\"  - Second Index: \",fourth_level_second_index)\n",
    "    print(\"  - All Indexes so far: \",all_indexes_tree)\n",
    "    print(\"\")\n",
    "    \n",
    "    print(\"  - All Indexes so far: \",all_indexes_tree)\n",
    "    print(\"\")\n",
    "    ####################################################################################################\n",
    "     \n",
    "        \n",
    "    #SPLIT THE ACTIVATIONS, ACTIONS AND INDEXES IN LEAF, INTERMEDIATE & FINAL LEVEL: ###################\n",
    "    leaf_level_activations=activations[0:n_base]\n",
    "    leaf_level_actions=actions[0:n_base]\n",
    "    leaf_level_indexes=all_indexes_tree[0:n_base]\n",
    "    print(\"  1.1. First Level / Leaf Nodes:\")\n",
    "    print(\"     - Activations: \",leaf_level_activations)\n",
    "    print(\"     - Actions: \",leaf_level_actions)\n",
    "    print(\"     - Indexes: \",leaf_level_indexes)\n",
    "    print(\"\")\n",
    "    \n",
    "    intermediate_level_activations=activations[n_base:-1]\n",
    "    intermediate_level_actions=actions[n_base:-1]\n",
    "    intermediate_level_indexes=all_indexes_tree[n_base:-1]\n",
    "    print(\"  1.2. Intermediate Nodes: \")\n",
    "    print(\"     - Activations: \",intermediate_level_activations)\n",
    "    print(\"     - Actions: \",intermediate_level_actions)\n",
    "    print(\"     - Indexes: \",intermediate_level_indexes)\n",
    "    print(\"\")\n",
    "    \n",
    "    final_level_activation=activations[-1]\n",
    "    final_level_action=actions[-1]\n",
    "    final_level_indexes=all_indexes_tree[-1]\n",
    "    print(\"  1.3. Final Node: \")\n",
    "    print(\"     - Activations: \",final_level_activation)\n",
    "    print(\"     - Actions: \",final_level_action)\n",
    "    print(\"     - Indexes: \",final_level_indexes)\n",
    "    print(\"\")\n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    #SAMPLE HYPERPARAMETER FOR THE CELL INJECT AND NEW CELL STATE: #####################################\n",
    "    cell_inject_new_state=list(range(len(all_indexes_tree)))\n",
    "    print(\"  1.4. Cell Inject & new Cell State: \")\n",
    "    print(\"     - Sample new Cell State Index & Cell Inject Index from: \",cell_inject_new_state)\n",
    "    index_new_cell_state=trial.suggest_categorical('index_new_cell_state', cell_inject_new_state)\n",
    "    index_cell_inject=trial.suggest_categorical('index_cell_inject', cell_inject_new_state)\n",
    "    activation_cell_inject=trial.suggest_categorical('activation_cell_inject', [\"relu\",\"tanh\",\"sigmoid\",\"linear\"])\n",
    "    action_cell_inject=trial.suggest_categorical('action_cell_inject', [\"add\",\"elem_multi\"])\n",
    "    print(\"     - Index new Cell State: \",index_new_cell_state)\n",
    "    print(\"     - Index Cell Inject: \",index_cell_inject)\n",
    "    print(\"     - Activation Cell Inject: \",activation_cell_inject)\n",
    "    print(\"     - Action Cell Inject: \",action_cell_inject+\"\\n\")\n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    #SAMPLE FURTHER HYPERPARAMETERS: ###################################################################\n",
    "    \n",
    "    \n",
    "    dropout_1=trial.suggest_categorical('dropout_1', [0.0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5])\n",
    "    dropout_2=trial.suggest_categorical('dropout_2', [0.0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5])\n",
    "    \n",
    "    neurons_1=trial.suggest_int('neurons_1', low=100, high=800, step=50)\n",
    "    neurons_2=trial.suggest_int('neurons_2', low=100, high=800, step=50)\n",
    "    #use_regularizer=trial.suggest_categorical('use_regularizer', [True,False])\n",
    "    \n",
    "    type_weights_regularizer=trial.suggest_categorical('type_regularizer', [\"L1\",\"L2\"])\n",
    "    rl_value=trial.suggest_categorical('rl_value', \n",
    "                                           [0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009,\n",
    "                                           0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09,0.1])\n",
    "    \n",
    "    \n",
    "    epochs=trial.suggest_categorical('epochs', [100,150,200])\n",
    "    \n",
    "    batch_size=trial.suggest_categorical('batch_size', [32,64,128])\n",
    "    \n",
    "    window_size=trial.suggest_int('window_size', low=5, high=50, step=1)\n",
    "    \n",
    "    \n",
    "    lr_value=trial.suggest_discrete_uniform('lr_value', 0.001,0.01,0.001)\n",
    "    lr_value=round(lr_value,5)\n",
    "    #clipvalue=trial.suggest_categorical('clipvalue',[1.0,1.5,2.0])#,1.0,1.5,2.0])\n",
    "    ####################################################################################################\n",
    "    \n",
    "    #Currently fix hyperparameters:\n",
    "    num_layers=2#fixed!\n",
    "    train_test_split=0.7#trial.suggest_categorical('train_test_split', [0.7,0.75,0.8])\n",
    "    \n",
    "    optimizer=\"adam\"#trial.suggest_categorical('optimizer', [\"adam\",\"Adagrad\"])\n",
    "    \n",
    "    callbacks_patience=10#trial.suggest_categorical('callbacks_patience', [10,15])\n",
    "    early_stop=EarlyStopping(monitor='val_loss', mode='min',min_delta=0.01, \n",
    "                             verbose=0, patience=callbacks_patience, \n",
    "                             restore_best_weights=True)\n",
    "    callbacks=[early_stop]\n",
    "    \n",
    "    \n",
    "    #PRINT OUT SUMMARY OF SAMPLED HYPERPARAMETERS TO KEEP TRACK OF THE OPTIMIZATION: ###################\n",
    "    print(\"2. FURTHER HYPERPARAMETERS:\"+\"\\n\")\n",
    "    print(\"  2.1. UNCONDITIONAL:\"+\"\\n\")\n",
    "    print(\"     - Window Size Sequences: \"+str(window_size))\n",
    "    print(\"     - Sequential Split: first \"+str(train_test_split*100)+\"% train set, the rest \"+str(round((1-train_test_split),2)*100)+\"% test set\")\n",
    "    print(\"     - Number Layers: \"+str(num_layers))\n",
    "    print(\"     - Number Neurons 1. Layer: \"+str(neurons_1))\n",
    "    print(\"     - Number Neurons 2. Layer: \"+str(neurons_2))\n",
    "    \n",
    "    #print(\"  - Activation Function: \"+activation)\n",
    "    print(\"     - Dropout after 1. Layer: \"+str(dropout_1))\n",
    "    print(\"     - Dropout before final Dense Layer: \"+str(dropout_2))\n",
    "    print(\"     - Batch Size: \"+str(batch_size))\n",
    "    print(\"     - Epochs: \"+str(epochs))\n",
    "    print(\"     - Callbacks (Patience): \"+str(callbacks_patience))\n",
    "    print(\"     - Optimizer: \"+optimizer)\n",
    "    print(\"     - Learning Rate Value: \"+str(lr_value))\n",
    "    print(\"     - Type Regularization: \"+type_weights_regularizer)\n",
    "    print(\"     - Decay for Regularization: \"+str(rl_value)+\"\\n\")   \n",
    "    \n",
    "    #print(\"     - Clip-Norm: \"+str(clipvalue))\n",
    "    \n",
    "    \n",
    "     \n",
    "    ###################################################################################################        \n",
    "    #DATA PREPROCESSING: ###############################################################################\n",
    "    relevant_data=synthetic_time_series_combined_kernel.copy()#synthetic_data[0].copy()\n",
    "    X_sequences, y_sequences=split_sequence_univariate(relevant_data.values, window_size)\n",
    "    X_sequences=X_sequences.reshape(X_sequences.shape[0],X_sequences.shape[1],1)\n",
    "    y_sequences=y_sequences.reshape(y_sequences.shape[0],1)\n",
    "    train_size=train_size=int(train_test_split*len(X_sequences))\n",
    "    X_train, X_test =X_sequences[:train_size],X_sequences[train_size:]\n",
    "    y_train,y_test=y_sequences[:train_size],y_sequences[train_size:]\n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    #BUILD AND TRAIN THE RNN-MODEL WITH THE SAMPLED HYPERPARAMETERS (CUSTOM-RNN-CELL): #################\n",
    "    \n",
    "    #USE WHEN TESTING CUSTOM RNN CELL: #############################################################\n",
    "    model=build_custom_model(type_weights_regularizer,rl_value,\n",
    "                      X_train,n_base,neurons_1,neurons_2,dropout_1,dropout_2,\n",
    "                      optimizer,lr_value,\n",
    "                      leaf_level_activations,leaf_level_actions,\n",
    "                      index_cell_inject,action_cell_inject,activation_cell_inject,\n",
    "                      index_new_cell_state,\n",
    "                      intermediate_level_indexes,intermediate_level_activations,intermediate_level_actions,\n",
    "                      final_level_indexes,final_level_activation,final_level_action,clip_gradients=False,\n",
    "                      clipvalue=None)\n",
    "    ####################################################################################################\n",
    "    \n",
    "    print(\"3. KERAS ARCHITECTURE SUMMARY:\")\n",
    "    print(model.summary())\n",
    "    \n",
    "    #TRY FITTING THE SAMPLED RNN-MODEL:\n",
    "    try:\n",
    "        history_fitted_model=model.fit(X_train, y_train, \n",
    "                                   epochs=epochs, batch_size=batch_size, \n",
    "                                   validation_data=[X_test,y_test],verbose=1,\n",
    "                                   callbacks=callbacks)\n",
    "        output=\"no_nans\"\n",
    "    except TypeError:\n",
    "        #IF THE ERROR OCCURS: THE MODEL PRODUCED NANS, REPLACING THE FINAL ACTIVATION LAYER\n",
    "        #WITH ONE THAT SQUASHES THE VALUES FOR THE NEW HIDDEN STATE MORE: TANH OR SIGMOID\n",
    "        print(\"     - The model produced nans, changing final Activation Function: \")   \n",
    "        change_final_activation=trial.suggest_categorical(\"change_final_activation\",[\"tanh\",\"sigmoid\"])\n",
    "        final_level_activation=change_final_activation\n",
    "        print(\"     - New Final Activation Function: \"+final_level_activation+\"\\n\")   \n",
    "        model=build_custom_model(type_weights_regularizer,rl_value,\n",
    "                      X_train,n_base,neurons_1,neurons_2,dropout_1,dropout_2,\n",
    "                      optimizer,lr_value,\n",
    "                      leaf_level_activations,leaf_level_actions,\n",
    "                      index_cell_inject,action_cell_inject,activation_cell_inject,\n",
    "                      index_new_cell_state,\n",
    "                      intermediate_level_indexes,intermediate_level_activations,intermediate_level_actions,\n",
    "                      final_level_indexes,final_level_activation,final_level_action,clip_gradients=False,\n",
    "                      clipvalue=None)\n",
    "        try:\n",
    "            history_fitted_model=model.fit(X_train, y_train, \n",
    "                                   epochs=epochs, batch_size=batch_size, \n",
    "                                   validation_data=[X_test,y_test],verbose=1,\n",
    "                                   callbacks=callbacks) \n",
    "            output=\"no_nans\"\n",
    "        except KeyError:\n",
    "            output=\"nans\"\n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    #GENERATE PREDICTIONS, REVERSE THE SCALE AND COMPUTE MAPE: #########################################\n",
    "    if output==\"no_nans\":\n",
    "        print(\"4. KERAS TRAIN-TEST LOSS-PLOT:\")\n",
    "        keras_plot(history_fitted_model)\n",
    "        predictions=model.predict(X_test,verbose=0)\n",
    "    \n",
    "        y_test=y_test.reshape(y_test.shape[0])\n",
    "        predictions=predictions.reshape(predictions.shape[0])\n",
    "        mape=compute_mape(y_test,predictions)\n",
    "        mape=round(mape,5)\n",
    "    \n",
    "        print(\"5. MAPE CURRENT TRIAL: \"+str(mape))\n",
    "        print(\"\"+\"\\n\")\n",
    "\n",
    "        print(\"6. PLOT PREDICTIONS VS. TRUE VALUES:\")\n",
    "        plt.figure(figsize=(15,10))\n",
    "        plt.plot(predictions)\n",
    "        plt.plot(y_test)\n",
    "    \n",
    "        plt.title('PREDICTIONS VS. TRUE')\n",
    "        plt.legend(['Predictions', 'True'], loc='upper left')\n",
    "        plt.show()\n",
    "        print(\"\"+\"\\n\")\n",
    "    else:\n",
    "        mape=np.float(\"nan\")\n",
    "    \n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    return mape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- **Example of RNN-Cell sampled with Optuna**:\n",
    "        - Leaf Nodes:\n",
    "             - Indexes of Leaf Nodes:  [0, 1, 2, 3, 4, 5, 6, 7] \n",
    "               (not sampled, number of leaf-indexes set to 8 as advised so in the paper\n",
    "               \"Neural Architecture Search with Reinforcement Learning\")\n",
    "             - Actions:  ['elem_multi', 'add', 'elem_multi', 'add', 'add', 'elem_multi', 'add', 'elem_multi']\n",
    "             - Activations:  ['linear', 'relu', 'tanh', 'tanh', 'sigmoid', 'linear', 'sigmoid', 'linear']\n",
    "             \n",
    "        - Intermediate Nodes (Second-Level):\n",
    "            - Indexes (connecting Leaf Nodes):  [[0, 2], [1, 3], [4, 6], [5, 7]]\n",
    "            - Actions:  ['add', 'elem_multi', 'elem_multi', 'elem_multi']\n",
    "            - Activations:  ['linear', 'linear', 'tanh', 'sigmoid']     \n",
    "            \n",
    "        - Intermediate Nodes (Third-Level):\n",
    "            - Indexes (connecting Second-Level Intermediate Nodes):  [[8, 11], [9, 10]]\n",
    "            - Actions: ['relu', 'relu']\n",
    "            - Activations: ['elem_multi', 'add']\n",
    "            \n",
    "        - Final Node:\n",
    "            - Indexes (connecting Third-Level Intermediate Nodes) [13, 12] (always the same)\n",
    "            - Actions:  add\n",
    "            - Activations:  linear\n",
    "            \n",
    "        - New Cell State:\n",
    "            - Index: 11\n",
    "        \n",
    "        - Inject Previous Cell State:\n",
    "            - Index: 0\n",
    "            - Action: add\n",
    "            - Activation: relu\n",
    "     \n",
    "     "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- **Visualizing the sampled RNN Cell**:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"https://github.com/gvelev123/Master_Thesis/blob/master/Jupyter_Notebook/custom_RNN_Cell.png?raw=true\">"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "        - the Leaf Nodes (Tree Index 0 to 7):\n",
    "          take as inputs the current state \"x t\" and the hidden state \"h t-1\"\n",
    "          \n",
    "        - the Cell Inject Node: overwrites the output of Tree Index 0\n",
    "        \n",
    "        - the new Cell State: taken from Tree Index 11 before the Activation Function is applied\n",
    "        \n",
    "        - Tree Index 8 to 13: intermediate Nodes\n",
    "        \n",
    "        - Tree Index 14: final Node"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Function for building the RNN from the Hyperparameters sampled by Optuna:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from keras.layers import Lambda,BatchNormalization\n",
    "def build_custom_model(type_weights_regularizer,rl_value,\n",
    "                      X_train,n_base,neurons_1,neurons_2,dropout_1,dropout_2,\n",
    "                      optimizer,lr_value,\n",
    "                      leaf_level_activations,leaf_level_actions,\n",
    "                      index_cell_inject,action_cell_inject,activation_cell_inject,\n",
    "                      index_new_cell_state,\n",
    "                      intermediate_level_indexes,intermediate_level_activations,intermediate_level_actions,\n",
    "                      final_level_indexes,final_level_activation,final_level_action,\n",
    "                      clip_gradients,clipvalue=None):   \n",
    "    \n",
    "    if type_weights_regularizer==\"L1\":\n",
    "        weights_regularizer=keras.regularizers.l1(rl_value)\n",
    "    else:\n",
    "        weights_regularizer=keras.regularizers.l2(rl_value)\n",
    "    \n",
    "    \n",
    "    \n",
    "    model=keras.models.Sequential()\n",
    "    input_layer = keras.layers.InputLayer(input_shape=(X_train.shape[1:]))\n",
    "    model.add(input_layer)\n",
    "    \n",
    "\n",
    "    #CREATE THE ACTUAL CUSTOM RNN CELL:\n",
    "    custom_rnn_cell_1=Custom_RNNCell_tree(\n",
    "                units=neurons_1,\n",
    "                 base=n_base,\n",
    "                 #Leaf Nodes:\n",
    "                 activations_leaf_nodes=leaf_level_activations,\n",
    "                 actions_leaf_nodes=leaf_level_actions,\n",
    "                 #Cell Inject:\n",
    "                 index_cell_inject=index_cell_inject,\n",
    "                 action_cell_inject=action_cell_inject,\n",
    "                 activation_cell_inject=activation_cell_inject,\n",
    "                 #New Cell State:\n",
    "                 index_new_cell_state=index_new_cell_state,\n",
    "                 #Intermediate Levels (Internal Nodes):\n",
    "                 index_intermediate_levels=intermediate_level_indexes,\n",
    "                 activations_intermediate_levels=intermediate_level_activations,\n",
    "                 actions_intermediate_levels=intermediate_level_actions,\n",
    "                 #Final Node:\n",
    "                 index_last_node=final_level_indexes,\n",
    "                 activation_last_node=final_level_activation,\n",
    "                 action_last_node=final_level_action,\n",
    "                 kernel_regularizer=weights_regularizer,\n",
    "                 recurrent_regularizer=weights_regularizer)\n",
    "    \n",
    "    rnn_layer_1=keras.layers.RNN(custom_rnn_cell_1,return_sequences=True)                               \n",
    "        \n",
    "    model.add(rnn_layer_1)\n",
    "    \n",
    "    #ADD DROPOUT IF >0.0:\n",
    "    if dropout_1>0.0:\n",
    "        model.add(Dropout(dropout_1))\n",
    "    \n",
    "    custom_rnn_cell_2=Custom_RNNCell_tree(\n",
    "                units=neurons_2,\n",
    "                 base=n_base,\n",
    "                 #Leaf Nodes:\n",
    "                 activations_leaf_nodes=leaf_level_activations,\n",
    "                 actions_leaf_nodes=leaf_level_actions,\n",
    "                 #Cell Inject:\n",
    "                 index_cell_inject=index_cell_inject,\n",
    "                 action_cell_inject=action_cell_inject,\n",
    "                 activation_cell_inject=activation_cell_inject,\n",
    "                 #New Cell State:\n",
    "                 index_new_cell_state=index_new_cell_state,\n",
    "                 #Intermediate Levels (Internal Nodes):\n",
    "                 index_intermediate_levels=intermediate_level_indexes,\n",
    "                 activations_intermediate_levels=intermediate_level_activations,\n",
    "                 actions_intermediate_levels=intermediate_level_actions,\n",
    "                 #Final Node:\n",
    "                 index_last_node=final_level_indexes,\n",
    "                 activation_last_node=final_level_activation,\n",
    "                 action_last_node=final_level_action,\n",
    "                 kernel_regularizer=weights_regularizer,\n",
    "                 recurrent_regularizer=weights_regularizer)\n",
    "    \n",
    "    \n",
    "    rnn_layer_2=keras.layers.RNN(custom_rnn_cell_2,return_sequences=False)                               \n",
    "        \n",
    "    model.add(rnn_layer_2)\n",
    "    \n",
    "    #ADD DROPOUT IF >0.0:\n",
    "    if dropout_2>0.0:\n",
    "        model.add(Dropout(dropout_2))\n",
    "     \n",
    "    \n",
    "    \n",
    "    model.add(Dense(1,activation=\"linear\"))\n",
    "    loss=\"mse\"#rmse\n",
    "    #OPTIMIZER:\n",
    "    if optimizer==\"adam\":\n",
    "        if clip_gradients==True:\n",
    "            model.compile(optimizer=keras.optimizers.Adam(learning_rate=lr_value,clipvalue=clipvalue),\n",
    "                      loss=loss)\n",
    "        else:\n",
    "            model.compile(optimizer=keras.optimizers.Adam(learning_rate=lr_value),\n",
    "                      loss=loss)\n",
    "                          \n",
    "    else:# optimizer==\"Adagrad\":\n",
    "        if clip_gradients==True:\n",
    "            model.compile(optimizer=keras.optimizers.Adagrad(learning_rate=lr_value,clipvalue=clipvalue),\n",
    "                      loss=loss)\n",
    "        else: \n",
    "            model.compile(optimizer=keras.optimizers.Adagrad(learning_rate=lr_value),\n",
    "                      loss=loss)\n",
    "    return model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.2.2. Objective Function for LSTM:\n",
    "- **includes the same hyperparameters as the Objective Function for custom RNN-Cell**:<br>\n",
    "        - except the ones for the NAS part (not relevant for LSTM-Cells)\n",
    "        \n",
    "        - aim: get a fair baseline model\n",
    "\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [],
   "source": [
    "import optuna\n",
    "### import extra_keras_metrics\n",
    "def objective_LSTM(trial): \n",
    "    seed(123)\n",
    "    set_seed(123)\n",
    "    \n",
    "    print(\"SUMMARY CURRENT TRIAL: \"+\"\\n\")\n",
    "    #SAMPLE FURTHER HYPERPARAMETERS: ###################################################################    \n",
    "    dropout_1=trial.suggest_categorical('dropout_1', [0.0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5])\n",
    "    dropout_2=trial.suggest_categorical('dropout_2', [0.0,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5])\n",
    "    \n",
    "    neurons_1=trial.suggest_int('neurons_1', low=100, high=800, step=50)\n",
    "    neurons_2=trial.suggest_int('neurons_2', low=100, high=800, step=50)\n",
    "\n",
    "    type_weights_regularizer=trial.suggest_categorical('type_regularizer', [\"L1\",\"L2\"])\n",
    "    rl_value=trial.suggest_categorical('rl_value', \n",
    "                                           [0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009,\n",
    "                                           0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09,0.1])\n",
    "    \n",
    "    activation=trial.suggest_categorical('activation', [\"relu\",\"tanh\"])\n",
    "    \n",
    "    epochs=trial.suggest_categorical('epochs', [100,150,200])\n",
    "    \n",
    "    batch_size=trial.suggest_categorical('batch_size', [32,64,128])\n",
    "    \n",
    "    window_size=trial.suggest_int('window_size', low=10, high=50, step=1)\n",
    "    \n",
    "    \n",
    "    lr_value=trial.suggest_discrete_uniform('lr_value', 0.001,0.01,0.001)\n",
    "    lr_value=round(lr_value,5)\n",
    "    #clipvalue=trial.suggest_categorical('clipvalue',[1.0,1.5,2.0])#,1.0,1.5,2.0])\n",
    "    ####################################################################################################\n",
    "    \n",
    "    #Currently fix hyperparameters:\n",
    "    num_layers=2#fixed!\n",
    "    optimizer=\"adam\"\n",
    "    callbacks_patience=10\n",
    "    early_stop=EarlyStopping(monitor='val_loss', mode='min',min_delta=0.01, \n",
    "                             verbose=0, patience=callbacks_patience, \n",
    "                             restore_best_weights=True)\n",
    "    callbacks=[early_stop]\n",
    "    train_test_split=0.7\n",
    "    \n",
    "    #PRINT OUT SUMMARY OF SAMPLED HYPERPARAMETERS TO KEEP TRACK OF THE OPTIMIZATION: ###################\n",
    "    print(\"2. FURTHER HYPERPARAMETERS:\"+\"\\n\")\n",
    "    print(\"  2.1. UNCONDITIONAL:\"+\"\\n\")\n",
    "    print(\"     - Window Size Sequences: \"+str(window_size))\n",
    "    print(\"     - Sequential Split: first \"+str(train_test_split*100)+\"% train set, the rest \"+str(round((1-train_test_split),2)*100)+\"% test set\")\n",
    "    print(\"     - Number Layers: \"+str(num_layers))\n",
    "    print(\"     - Number Neurons 1. Layer: \"+str(neurons_1))\n",
    "    print(\"     - Number Neurons 2. Layer: \"+str(neurons_2))\n",
    "    \n",
    "    #print(\"  - Activation Function: \"+activation)\n",
    "    print(\"     - Dropout after 1. Layer: \"+str(dropout_1))\n",
    "    print(\"     - Dropout before final Dense Layer: \"+str(dropout_2))\n",
    "    print(\"     - Batch Size: \"+str(batch_size))\n",
    "    print(\"     - Epochs: \"+str(epochs))\n",
    "    print(\"     - Callbacks (Patience): \"+str(callbacks_patience))\n",
    "    print(\"     - Optimizer: \"+optimizer)\n",
    "    print(\"     - Learning Rate Value: \"+str(lr_value))\n",
    "    print(\"     - Type Regularization: \"+type_weights_regularizer)\n",
    "    print(\"     - Decay for Regularization: \"+str(rl_value)+\"\\n\")   \n",
    "    \n",
    "     \n",
    "    ###################################################################################################        \n",
    "    #DATA PREPROCESSING: ###############################################################################\n",
    "    relevant_data=fBm_synthetic_data.copy()#synthetic_data[0].copy()\n",
    "    X_sequences, y_sequences=split_sequence_univariate(relevant_data.values, window_size)\n",
    "    X_sequences=X_sequences.reshape(X_sequences.shape[0],X_sequences.shape[1],1)\n",
    "    y_sequences=y_sequences.reshape(y_sequences.shape[0],1)\n",
    "    train_size=train_size=int(train_test_split*len(X_sequences))\n",
    "    X_train, X_test =X_sequences[:train_size],X_sequences[train_size:]\n",
    "    y_train,y_test=y_sequences[:train_size],y_sequences[train_size:]\n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    #BUILD AND TRAIN THE RNN-MODEL WITH THE SAMPLED HYPERPARAMETERS: #################    \n",
    "    #USE WHEN TESTING BASELINE MODEL: LSTM: #############################################################\n",
    "    \n",
    "    if type_weights_regularizer==\"L1\":\n",
    "        weights_regularizer=keras.regularizers.l1(rl_value)\n",
    "    else:\n",
    "        weights_regularizer=keras.regularizers.l2(rl_value)\n",
    "    \n",
    "    model=keras.models.Sequential()\n",
    "    input_layer = keras.layers.InputLayer(input_shape=(X_train.shape[1:]))\n",
    "    model.add(input_layer)\n",
    "                               \n",
    "        \n",
    "    model.add(keras.layers.LSTM(units=neurons_1,activation=activation,return_sequences=True,\n",
    "                                kernel_regularizer=weights_regularizer,\n",
    "                                recurrent_regularizer=weights_regularizer))\n",
    "    \n",
    "    #ADD DROPOUT IF >0.0:\n",
    "    if dropout_1>0.0:\n",
    "        model.add(Dropout(dropout_1))\n",
    "    \n",
    "    model.add(keras.layers.LSTM(units=neurons_2,activation=activation,return_sequences=False,\n",
    "                                kernel_regularizer=weights_regularizer,\n",
    "                                recurrent_regularizer=weights_regularizer))\n",
    "    #ADD DROPOUT IF >0.0:\n",
    "    if dropout_2>0.0:\n",
    "        model.add(Dropout(dropout_2))\n",
    "     \n",
    "    \n",
    "    \n",
    "    model.add(Dense(1,activation=\"linear\"))\n",
    "    loss=\"mse\"#rmse\n",
    "    clip_gradients=False\n",
    "    #OPTIMIZER:\n",
    "    if optimizer==\"adam\":\n",
    "        if clip_gradients==True:\n",
    "            model.compile(optimizer=keras.optimizers.Adam(learning_rate=lr_value,clipvalue=clipvalue),\n",
    "                      loss=loss)\n",
    "        else:\n",
    "            model.compile(optimizer=keras.optimizers.Adam(learning_rate=lr_value),\n",
    "                      loss=loss)\n",
    "                          \n",
    "    else:# optimizer==\"Adagrad\":\n",
    "        if clip_gradients==True:\n",
    "            model.compile(optimizer=keras.optimizers.Adagrad(learning_rate=lr_value,clipvalue=clipvalue),\n",
    "                      loss=loss)\n",
    "        else: \n",
    "            model.compile(optimizer=keras.optimizers.Adagrad(learning_rate=lr_value),\n",
    "                      loss=loss)\n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    print(\"3. KERAS ARCHITECTURE SUMMARY:\")\n",
    "    print(model.summary())\n",
    "    \n",
    "    #TRY FITTING THE SAMPLED RNN-MODEL:\n",
    "    try:\n",
    "        history_fitted_model=model.fit(X_train, y_train, \n",
    "                                   epochs=epochs, batch_size=batch_size, \n",
    "                                   validation_data=[X_test,y_test],verbose=1,\n",
    "                                   callbacks=callbacks)\n",
    "        output=\"no_nans\"\n",
    "    except TypeError:\n",
    "        output=\"nans\" \n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    #GENERATE PREDICTIONS, REVERSE THE SCALE AND COMPUTE MAPE: #########################################\n",
    "    if output==\"no_nans\":\n",
    "        print(\"4. KERAS TRAIN-TEST LOSS-PLOT:\")\n",
    "        keras_plot(history_fitted_model)\n",
    "        predictions=model.predict(X_test,verbose=0)\n",
    "    \n",
    "        y_test=y_test.reshape(y_test.shape[0])\n",
    "        predictions=predictions.reshape(predictions.shape[0])\n",
    "        mape=compute_mape(y_test,predictions)\n",
    "        mape=round(mape,5)\n",
    "    \n",
    "        print(\"5. MAPE CURRENT TRIAL: \"+str(mape))\n",
    "        print(\"\"+\"\\n\")\n",
    "\n",
    "        print(\"6. PLOT PREDICTIONS VS. TRUE VALUES:\")\n",
    "        plt.figure(figsize=(15,10))\n",
    "        plt.plot(predictions)\n",
    "        plt.plot(y_test)\n",
    "    \n",
    "        plt.title('PREDICTIONS VS. TRUE')\n",
    "        plt.legend(['Predictions', 'True'], loc='upper left')\n",
    "        plt.show()\n",
    "        print(\"\"+\"\\n\")\n",
    "    else:\n",
    "        mape=np.float(\"nan\")\n",
    "    \n",
    "    ####################################################################################################\n",
    "    \n",
    "    \n",
    "    return mape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Further Functions: "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.1. Splitting the Data into Sequences: Univariate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Sequence-Splitting for univariate Timeseries:\n",
    "def split_sequence_univariate(sequence, n_steps):\n",
    "    X, y = list(), list()\n",
    "    for i in range(len(sequence)):\n",
    "        # find the end of this pattern\n",
    "        end_ix = i + n_steps\n",
    "        # check if we are beyond the sequence\n",
    "        if end_ix > len(sequence)-1:\n",
    "            break\n",
    "         #gather input and output parts of the pattern\n",
    "        seq_x, seq_y = sequence[i:end_ix], sequence[end_ix]\n",
    "        X.append(seq_x)\n",
    "        y.append(seq_y)\n",
    "    return np.array(X), np.array(y)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.2. Keras Plot Train vs. Test History: "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "def keras_plot(history):\n",
    "    # Plot training & validation loss values\n",
    "    plt.plot(history.history['loss'])\n",
    "    plt.plot(history.history['val_loss'])\n",
    "    plt.title('Model loss')\n",
    "    plt.ylabel('Loss')\n",
    "    plt.xlabel('Epoch')\n",
    "    plt.legend(['Train', 'Test'], loc='upper left')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.3. Compute Mean-Absolute-Percentage-Error (MAPE) for the Predictions & the True Values:\n",
    "- MAPE used as the evaluation metric in the Optuna-Trials"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def compute_mape(y_original_reversed,y_predictions_reversed):\n",
    "    mape=np.array(abs((y_original_reversed-y_predictions_reversed)/y_original_reversed)).mean()*100\n",
    "    return mape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Data Retrieval"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.1. Synthetic Data\n",
    "\n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.1.1. Simulating Fractional Brownian Motion:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- **Method of Cholesky**:\n",
    "        - create a sequence of numbers\n",
    "        \n",
    "        - compute the kernel matrix of a standard Fractional Brownian Motion\n",
    "        \n",
    "        - apply Cholesky Decomposition\n",
    "        \n",
    "        - if N=number of samples to be simulated, sample N-1 values from the \n",
    "          standard Gaussian distribution \n",
    "          \n",
    "        - compute the product of the transposed decomposed matrix and the N-1 standard Gaussian samples\n",
    "        \n",
    "        - Source: \n",
    "        Simulation and Identification of the Franctional Brownian Motion: A bibliographical and comparative study \n",
    "        (Concept: p. 7-8, Code example: p. 29 in Appendix A.3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Link to the Source: https://scholar.google.com/scholar?hl=en&as_sdt=0%2C5&q=SIMULATION+AND+IDENTIFICATION+OF+THE+FRACTIONAL+BROWNIAN+MOTION%3A+A+BIBLIOGRAPHICAL+AND+COMPARATIVE+STUDY&btnG="
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          x\n",
      "0  0.000000\n",
      "1  0.005228\n",
      "2  0.015765\n",
      "3  0.017793\n",
      "4  0.022557\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Text(0.5, 0, 'Time')"
      ]
     },
     "execution_count": 54,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 720x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "fBm_synthetic_data = pd.read_csv(r\"/Users/i530967/desktop/fmB_data_simulted.csv\", sep=',',header=0)\n",
    "print(fBm_synthetic_data.head())\n",
    "plt.figure(figsize=(10,5))\n",
    "plt.plot(fBm_synthetic_data)\n",
    "plt.title('Fractional Brownian Motion: n=2000, H=0.7',fontsize=15)\n",
    "#plt.ylabel('Fractional Brownian Motion',fontsize=15)\n",
    "plt.xlabel('Time',fontsize=15)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.1.2. Simulating Time Series with R-Package GRATIS:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- **Link to Github-Repository**: https://github.com/ykang/gratis/blob/master/man/generate_ts_with_target.Rd"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- **Link to Paper**: https://arxiv.org/pdf/1903.02787.pdf\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- **The Package supports Simulating Time Series with controllable Features**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- **For Example, by using the function \"generate_ts_with_target()\" we can specify**:\n",
    "        - freq = Frequency of the Time Series\n",
    "        \n",
    "        - seasonal: 0 for non-seasonal data, \n",
    "          1 for single-seasonal data, \n",
    "          and 2 for multiple seasonal data\n",
    "          \n",
    "        - features = which feature-function to control, \n",
    "          for example entropy & stl features\n",
    "          \n",
    "        - selected.features = for example for stl_features: trend\n",
    "        \n",
    "        - target = the desired values for the features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          x\n",
      "0  1.387153\n",
      "1 -0.100260\n",
      "2 -1.422987\n",
      "3  0.494772\n",
      "4  0.670056\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Text(0.5, 0, 'Time')"
      ]
     },
     "execution_count": 55,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 720x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "ts_with_target = pd.read_csv(r\"/Users/i530967/desktop/ts_with_target.csv\", sep=',',header=0)\n",
    "print(ts_with_target.head())\n",
    "plt.figure(figsize=(10,5))\n",
    "plt.plot(ts_with_target)\n",
    "plt.title('Time Series with controllable Features: n=1, ts.length=2000, seasonal=1, freq=1, entropy=0.3, trend=0.5',fontsize=15)\n",
    "plt.xlabel('Time',fontsize=15)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.1.3. Simulating a Gaussian Process:\n",
    "- **Simulating a Gaussian Process (GP) involves**:\n",
    "        - 1. Step: generate (ordered) sequence of numbers x={x1,x2,...x n}\n",
    "        \n",
    "        - 2. Step: generate covariance matrix K(x,x) by applying a particular kernel function k\n",
    "                   to each pair of points from the sequence x\n",
    "        \n",
    "        - 3. Step: generate synthetic time series by passing the covariance matrix & mean vector\n",
    "                   of zeros to numpy.random.multivariate_normal\n",
    "                   \n",
    "        - 4. Step (Optinal): generate (for example) white noise & add it to the synthetic time series\n",
    "                             (White Noise Kernel: k(x,x)= ^2 x Identity Matrix) \n",
    "<br>        \n",
    "- **Kernel Function for Local Periodic Signal**: <br> <br>\n",
    "    combines Squarred Exponential Kernel & Exp-Sine-Squared (Periodic) kernel\n",
    "                   \n",
    "                   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow.compat.v1 as tf\n",
    "import tensorflow_probability as tfp\n",
    "tf_distributions = tfp.distributions\n",
    "tf_kernels = tfp.math.psd_kernels\n",
    "\n",
    "#Source: https://peterroelants.github.io/posts/gaussian-process-kernels/\n",
    "\n",
    "def combined_covariance(periodic_amplitude, periodic_length_scale,exponential_quadratic_length_scale,\n",
    "                        period, sequence):\n",
    "    \"\"\"Local Periodic Kernel: combines Squarred Exponential Kernel & Exp-Sine-Squared (Periodic) kernel\"\"\"\n",
    "    #Amplitude: used for only for the periodic kernel:\n",
    "    periodic_amplitude_tf = tf.constant(periodic_amplitude, dtype=tf.float64)\n",
    "    exponential_quadratic_amplitude_tf=1#always!\n",
    "    \n",
    "    #Length Scale for each of the kernels:\n",
    "    periodic_length_scale_tf = tf.constant(periodic_length_scale, dtype=tf.float64)# (Periodic Kernel)\n",
    "    exponential_quadratic_length_scale_tf = tf.constant(exponential_quadratic_length_scale, dtype=tf.float64)# (Exp-Quadratic Kernel)\n",
    "    \n",
    "    #Period: used only for the periodic kernel:\n",
    "    period_tf = tf.constant(period, dtype=tf.float64)\n",
    "    \n",
    "    combined_kernel=(\n",
    "    #Periodic Kernel: exp-sine-squared kernel\n",
    "    tf_kernels.ExpSinSquared(\n",
    "            amplitude=periodic_amplitude_tf, \n",
    "            length_scale=periodic_length_scale_tf,\n",
    "            period=period_tf) * \n",
    "    #Exponential Quadratic Kernel:\n",
    "    tf_kernels.ExponentiatedQuadratic(\n",
    "            length_scale=exponential_quadratic_length_scale_tf,\n",
    "            amplitude=exponential_quadratic_amplitude_tf))\n",
    "    \n",
    "    #Generate the Covariance Matrix:\n",
    "    kernel_matrix = combined_kernel.matrix(sequence, sequence)\n",
    "    kernel_matrix_readable=K.eval(kernel_matrix)\n",
    "    \n",
    "    return kernel_matrix_readable\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def white_noise(std,num_samples):\n",
    "    var_noise=std**2\n",
    "    cov_matrix=var_noise*np.eye(num_samples)\n",
    "    y = np.random.multivariate_normal(\n",
    "        mean=np.zeros(num_samples), cov=cov_matrix, \n",
    "        size=1)[0]\n",
    "    return y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Text(0.5, 0, 'Time')"
      ]
     },
     "execution_count": 56,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 720x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "seed(123)\n",
    "number_samples=2000\n",
    "#Start and End Point can be manipulated:\n",
    "start_point=-10\n",
    "end_point=10\n",
    "ordered_sequence=np.expand_dims(np.linspace(start_point,end_point, number_samples),1)\n",
    "\n",
    "#Amplitude = Variance\n",
    "amplitude=5\n",
    "\n",
    "#Length Scale EQ-Kernel = the length of the 'wiggles' in the function\n",
    "length_scale_eq=0.5\n",
    "\n",
    "#Period in Periodic-Kernel: the distnace between the repititions\n",
    "period=1\n",
    "\n",
    "#Length Scale Periodic-Kernel: the same as in EQ-Kernel\n",
    "length_scale_periodic=1\n",
    "\n",
    "mean_vector=np.zeros(number_samples)\n",
    "\n",
    "\n",
    "kernel_matrix_combined = combined_covariance(periodic_amplitude=amplitude,\n",
    "                                             periodic_length_scale=length_scale_periodic,\n",
    "                                             exponential_quadratic_length_scale=length_scale_eq,\n",
    "                                             period=period, sequence=ordered_sequence)\n",
    "\n",
    "synthetic_time_series_combined_kernel= np.random.multivariate_normal(\n",
    "    mean=mean_vector, cov=kernel_matrix_combined, \n",
    "    size=1)[0]\n",
    "\n",
    "noise=white_noise(std=0.05,num_samples=2000)\n",
    "\n",
    "synthetic_time_series_combined_kernel=synthetic_time_series_combined_kernel+noise\n",
    "synthetic_time_series_combined_kernel=pd.DataFrame({\"Local_Periodic_Signal\":synthetic_time_series_combined_kernel},\n",
    "                                                  columns=[\"Local_Periodic_Signal\"])\n",
    "plt.figure(figsize=(10,5))\n",
    "plt.plot(synthetic_time_series_combined_kernel)\n",
    "plt.title('Local Periodic Signal: n=2000, Leq=0.5, A=5, P=1, Lp=1',fontsize=15)\n",
    "#plt.ylabel('Local Periodic Signal',fontsize=15)\n",
    "plt.xlabel('Time',fontsize=15)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. NAS\n",
    "- **Number of hidden Layers**: \n",
    "        - currently fixed to 2 (for both LSTMs and custom RNN-Cells)\n",
    "        \n",
    "        - advised so in the paper \"Neural Architecture Search with Reinforcement Learning\"\n",
    "<br>\n",
    "\n",
    "- **The Seed for Numpy and Tensorflow**:\n",
    "        - set to a pre-specified value during the trials with Optuna in order to ensure reproducibility of the results\n",
    "        \n",
    "        - results obtained from the same models ran with the same hyperparameters will still vary a little bit \n",
    "          (due to the backend used, whether CPU or GPU is used etc.), but less compared to not setting the seeds\n",
    "          \n",
    "        - once optimal hyperparameters exracted from the trials with Optuna: test different seeds\n",
    "          in order to test for consistency of the results when randomization is introduced"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.1. Fractional Brownian Motion"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A) Baseline Model: LSTM"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Run 50 Trials with Optuna"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#Seeds set in the functions:\n",
    "study = optuna.create_study()\n",
    "study.optimize(objective_LSTM, n_trials=50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best Params LSTM for Brownian Motion Signal: \n",
      "{'dropout_1': 0.05, 'dropout_2': 0.45, 'neurons_1': 300, 'neurons_2': 800, 'type_regularizer': 'L2', 'rl_value': 0.002, 'activation': 'tanh', 'epochs': 150, 'batch_size': 64, 'window_size': 37, 'lr_value': 0.002}\n"
     ]
    }
   ],
   "source": [
    "best_params=study.best_trial.params\n",
    "print(\"Best Params LSTM for Brownian Motion Signal: \")\n",
    "print(best_params)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Results from 1 Run with the optimal Hyperparameters with a pre-specified seed:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "seed(123)\n",
    "set_seed(123)\n",
    "\n",
    "X_sequences, y_sequences=split_sequence_univariate(fBm_synthetic_data.values, 37)\n",
    "train_size=train_size=int(0.7*len(X_sequences))\n",
    "X_train, X_test =X_sequences[:train_size],X_sequences[train_size:]\n",
    "y_train,y_test=y_sequences[:train_size],y_sequences[train_size:]\n",
    "\n",
    "model=keras.models.Sequential()\n",
    "input_layer = keras.layers.InputLayer(input_shape=(X_train.shape[1:]))\n",
    "model.add(input_layer)\n",
    "model.add(keras.layers.LSTM(units=300,activation=\"tanh\",return_sequences=True,\n",
    "                                kernel_regularizer=keras.regularizers.l2(0.002),\n",
    "                                recurrent_regularizer=keras.regularizers.l2(0.002)))\n",
    "model.add(Dropout(0.05))\n",
    "model.add(keras.layers.LSTM(units=800,activation=\"tanh\",return_sequences=False,\n",
    "                                kernel_regularizer=keras.regularizers.l2(0.002),\n",
    "                                recurrent_regularizer=keras.regularizers.l2(0.002)))\n",
    "model.add(Dropout(0.45))\n",
    "model.add(Dense(1,activation=\"linear\"))\n",
    "model.compile(optimizer=keras.optimizers.Adam(learning_rate=0.002),\n",
    "                      loss=\"mse\")\n",
    "    #print(model.summary())\n",
    "early_stop=EarlyStopping(monitor='val_loss', mode='min',min_delta=0.01, \n",
    "                             verbose=0, patience=10, \n",
    "                             restore_best_weights=True)\n",
    "history_fitted_model=model.fit(X_train, y_train, \n",
    "                                   epochs=150, batch_size=64, \n",
    "                                   validation_data=[X_test,y_test],verbose=1,\n",
    "                                   callbacks=[early_stop])\n",
    "predictions=model.predict(X_test,verbose=0)\n",
    "    \n",
    "y_test=y_test.reshape(y_test.shape[0])\n",
    "predictions=predictions.reshape(predictions.shape[0])\n",
    "mape=compute_mape(y_test,predictions)\n",
    "mape=round(mape,5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train vs. Test Loss:\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MAPE LSTM from 1 Run with optimal Hyperparameters & pre-specified seed:  7.28421\n"
     ]
    }
   ],
   "source": [
    "print(\"Train vs. Test Loss:\")\n",
    "keras_plot(history_fitted_model)\n",
    "print(\"MAPE LSTM from 1 Run with optimal Hyperparameters & pre-specified seed: \",mape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Average Results from 10 Runs with the optimal Hyperparameters with different seeds:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "seed(123)\n",
    "seeds_to_test=np.random.randint(low=1,high=1000,size=10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "X_sequences, y_sequences=split_sequence_univariate(fBm_synthetic_data.values, 37)\n",
    "train_size=train_size=int(0.7*len(X_sequences))\n",
    "X_train, X_test =X_sequences[:train_size],X_sequences[train_size:]\n",
    "y_train,y_test=y_sequences[:train_size],y_sequences[train_size:]\n",
    "\n",
    "mape_results=[]\n",
    "models=[]\n",
    "history_fitted_models=[]\n",
    "for i in range(0,10):\n",
    "    seed(seeds_to_test[i])\n",
    "    set_seed(seeds_to_test[i])\n",
    "\n",
    "    print(i)\n",
    "    model=keras.models.Sequential()\n",
    "    input_layer = keras.layers.InputLayer(input_shape=(X_train.shape[1:]))\n",
    "    model.add(input_layer)\n",
    "    model.add(keras.layers.LSTM(units=300,activation=\"tanh\",return_sequences=True,\n",
    "                                kernel_regularizer=keras.regularizers.l2(0.002),\n",
    "                                recurrent_regularizer=keras.regularizers.l2(0.002)))\n",
    "    model.add(Dropout(0.05))\n",
    "    model.add(keras.layers.LSTM(units=800,activation=\"tanh\",return_sequences=False,\n",
    "                                kernel_regularizer=keras.regularizers.l2(0.002),\n",
    "                                recurrent_regularizer=keras.regularizers.l2(0.002)))\n",
    "    model.add(Dropout(0.45))\n",
    "    model.add(Dense(1,activation=\"linear\"))\n",
    "    model.compile(optimizer=keras.optimizers.Adam(learning_rate=0.002),\n",
    "                      loss=\"mse\")\n",
    "    #print(model.summary())\n",
    "    early_stop=EarlyStopping(monitor='val_loss', mode='min',min_delta=0.01, \n",
    "                             verbose=0, patience=10, \n",
    "                             restore_best_weights=True)\n",
    "    history_fitted_model=model.fit(X_train, y_train, \n",
    "                                   epochs=150, batch_size=64, \n",
    "                                   validation_data=[X_test,y_test],verbose=1,\n",
    "                                   callbacks=[early_stop])\n",
    "    predictions=model.predict(X_test,verbose=0)\n",
    "    \n",
    "    y_test=y_test.reshape(y_test.shape[0])\n",
    "    predictions=predictions.reshape(predictions.shape[0])\n",
    "    mape=compute_mape(y_test,predictions)\n",
    "    mape=round(mape,5)\n",
    "    print(\"Mape LSTM: \",mape)\n",
    "    \n",
    "    mape_results.append(mape)\n",
    "    models.append(model)\n",
    "    history_fitted_models.append(history_fitted_model)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Average Performance of the 10 Runs:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Average MAPE from 10 Runs (best LSTM) on Fractional Brownian Motion Signal when varying the seed:  6.73\n"
     ]
    }
   ],
   "source": [
    "print(\"Average MAPE from 10 Runs (best LSTM) on Fractional Brownian Motion Signal when varying the seed: \",round(np.mean(mape_results),3))\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Best Performance within the 10 Runs: minimal MAPE"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Minimal MAPE achieved within the 10 Runs:  5.492\n",
      "Training History of the Model that achieved minimal MAPE within the 10 Runs: \n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "print(\"Minimal MAPE achieved within the 10 Runs: \",round(np.min(mape_results),3))\n",
    "index_best_model=np.where(mape_results==np.min(mape_results))[0][0]\n",
    "best_model=models[index_best_model]\n",
    "best_history=history_fitted_models[index_best_model]\n",
    "print(\"Training History of the Model that achieved minimal MAPE within the 10 Runs: \")\n",
    "keras_plot(best_history)\n",
    "#best seed for LSTM: 989"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### B) RNN-Cell structured as a Tree"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Run 50 Trials with Optuna"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Seeds set in the function:\n",
    "study = optuna.create_study()\n",
    "study.optimize(objective_RNN_Tree, n_trials=50)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Results from 1 Run with the optimal Hyperparameters with a pre-specified seed:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#Set the random Set of Numpy and Tensorflow in order to get reproducible results:\n",
    "seed(123)\n",
    "set_seed(123)\n",
    "\n",
    "\n",
    "X_sequences, y_sequences=split_sequence_univariate(fBm_synthetic_data.values, 35)\n",
    "train_size=train_size=int(0.7*len(X_sequences))\n",
    "X_train, X_test =X_sequences[:train_size],X_sequences[train_size:]\n",
    "y_train,y_test=y_sequences[:train_size],y_sequences[train_size:]\n",
    "\n",
    "\n",
    "#Build the optimal Model using further optimal Hyperparameters sampled by Optuna:\n",
    "\n",
    "model=build_custom_model(type_weights_regularizer=\"L2\",rl_value=0.003,\n",
    "        X_train=X_train,\n",
    "        n_base=8,\n",
    "        neurons_1=550,\n",
    "        neurons_2=300,\n",
    "        dropout_1=0.05,\n",
    "        dropout_2=0.3,\n",
    "        optimizer=\"adam\",\n",
    "        lr_value=0.003,\n",
    "        leaf_level_activations=['tanh', 'relu', 'linear', 'sigmoid', 'tanh', 'tanh', 'tanh', 'linear'],\n",
    "        leaf_level_actions=['elem_multi', 'elem_multi', 'elem_multi', 'add', 'add', 'elem_multi', 'elem_multi', 'elem_multi'],\n",
    "        index_cell_inject=2,\n",
    "        action_cell_inject=\"add\",\n",
    "        activation_cell_inject=\"relu\",\n",
    "        index_new_cell_state=9,\n",
    "        intermediate_level_indexes=[[0, 6], [1, 4], [2, 7], [3, 5], [8, 11], [9, 10]],\n",
    "        intermediate_level_activations=['relu', 'tanh', 'tanh', 'relu', 'sigmoid', 'linear'],\n",
    "        intermediate_level_actions=['elem_multi', 'add', 'elem_multi', 'elem_multi', 'add', 'add'],\n",
    "        final_level_indexes=[13, 12],\n",
    "        final_level_activation=\"linear\",\n",
    "        final_level_action=\"elem_multi\",\n",
    "        clip_gradients=False,\n",
    "        clipvalue=None)\n",
    "\n",
    "#print(model.summary())\n",
    "early_stop=EarlyStopping(monitor='val_loss', mode='min',min_delta=0.01, \n",
    "                             verbose=0, patience=10, \n",
    "                             restore_best_weights=True)\n",
    "history_fitted_model=model.fit(X_train, y_train, \n",
    "                                   epochs=150, batch_size=32, \n",
    "                                   validation_data=[X_test,y_test],verbose=0,\n",
    "                                   callbacks=[early_stop])\n",
    "\n",
    "predictions=model.predict(X_test,verbose=0)\n",
    "    \n",
    "y_test=y_test.reshape(y_test.shape[0])\n",
    "predictions=predictions.reshape(predictions.shape[0])\n",
    "mape=compute_mape(y_test,predictions)\n",
    "mape=round(mape,5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train vs. Test Loss:\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MAPE custom RNN-Cell from 1 Run with optimal Hyperparameters & pre-specified seed:  2.35266\n"
     ]
    }
   ],
   "source": [
    "print(\"Train vs. Test Loss:\")\n",
    "keras_plot(history_fitted_model)\n",
    "print(\"MAPE custom RNN-Cell from 1 Run with optimal Hyperparameters & pre-specified seed: \",mape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Average Results from 10 Runs with the optimal Hyperparameters with different seeds:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "X_sequences, y_sequences=split_sequence_univariate(fBm_synthetic_data.values, 35)\n",
    "train_size=train_size=int(0.7*len(X_sequences))\n",
    "X_train, X_test =X_sequences[:train_size],X_sequences[train_size:]\n",
    "y_train,y_test=y_sequences[:train_size],y_sequences[train_size:]\n",
    "\n",
    "\n",
    "#Build the optimal Model using further optimal Hyperparameters sampled by Optuna:\n",
    "mape_results=[]\n",
    "models=[]\n",
    "history_fitted_models=[]\n",
    "for i in range(0,10):\n",
    "    seed(seeds_to_test[i])\n",
    "    set_seed(seeds_to_test[i])\n",
    "    \n",
    "    model=build_custom_model(type_weights_regularizer=\"L2\",rl_value=0.003,\n",
    "        X_train=X_train,\n",
    "        n_base=8,\n",
    "        neurons_1=550,\n",
    "        neurons_2=300,\n",
    "        dropout_1=0.05,\n",
    "        dropout_2=0.3,\n",
    "        optimizer=\"adam\",\n",
    "        lr_value=0.003,\n",
    "        leaf_level_activations=['tanh', 'relu', 'linear', 'sigmoid', 'tanh', 'tanh', 'tanh', 'linear'],\n",
    "        leaf_level_actions=['elem_multi', 'elem_multi', 'elem_multi', 'add', 'add', 'elem_multi', 'elem_multi', 'elem_multi'],\n",
    "        index_cell_inject=2,\n",
    "        action_cell_inject=\"add\",\n",
    "        activation_cell_inject=\"relu\",\n",
    "        index_new_cell_state=9,\n",
    "        intermediate_level_indexes=[[0, 6], [1, 4], [2, 7], [3, 5], [8, 11], [9, 10]],\n",
    "        intermediate_level_activations=['relu', 'tanh', 'tanh', 'relu', 'sigmoid', 'linear'],\n",
    "        intermediate_level_actions=['elem_multi', 'add', 'elem_multi', 'elem_multi', 'add', 'add'],\n",
    "        final_level_indexes=[13, 12],\n",
    "        final_level_activation=\"linear\",\n",
    "        final_level_action=\"elem_multi\",\n",
    "        clip_gradients=False,\n",
    "        clipvalue=None)\n",
    "\n",
    "    #print(model.summary())\n",
    "    early_stop=EarlyStopping(monitor='val_loss', mode='min',min_delta=0.01, \n",
    "                             verbose=0, patience=10, \n",
    "                             restore_best_weights=True)\n",
    "    history_fitted_model=model.fit(X_train, y_train, \n",
    "                                   epochs=150, batch_size=32, \n",
    "                                   validation_data=[X_test,y_test],verbose=1,\n",
    "                                   callbacks=[early_stop])\n",
    "    keras_plot(history_fitted_model)\n",
    "    predictions=model.predict(X_test,verbose=0)\n",
    "    \n",
    "    y_test=y_test.reshape(y_test.shape[0])\n",
    "    predictions=predictions.reshape(predictions.shape[0])\n",
    "    mape=compute_mape(y_test,predictions)\n",
    "    mape=round(mape,5)\n",
    "    print(\"MAPE custom RNN-Cell: \",mape)\n",
    "    \n",
    "    mape_results.append(mape)\n",
    "    models.append(model)\n",
    "    history_fitted_models.append(history_fitted_model)\n",
    "    \n",
    "    \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Average Performance of the 10 Runs:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Average MAPE from 10 Runs (best custom RNN-Cell) on Fractional Brownian Motion Signal when varying the seed:  4.837\n"
     ]
    }
   ],
   "source": [
    "print(\"Average MAPE from 10 Runs (best custom RNN-Cell) on Fractional Brownian Motion Signal when varying the seed: \",round(np.mean(mape_results),3))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Best Performance within the 10 Runs: minimal MAPE"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Minimal MAPE achieved within the 10 Runs:  2.75\n",
      "Training History of the Model that achieved minimal MAPE within the 10 Runs: \n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "print(\"Minimal MAPE achieved within the 10 Runs: \",round(np.min(mape_results),3))\n",
    "index_best_model=np.where(mape_results==np.min(mape_results))[0][0]\n",
    "best_model=models[index_best_model]\n",
    "best_history=history_fitted_models[index_best_model]\n",
    "print(\"Training History of the Model that achieved minimal MAPE within the 10 Runs: \")\n",
    "keras_plot(best_history)\n",
    "#best seed for custom RNN-Cell: 123"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Summary of the Results:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- **The optimal Hyperparameters sampled by Optuna from the 50 Trials**:\n",
    "\n",
    "    1) Window Size / Length of Sequence: \n",
    "        - LSTM: 37\n",
    "        - custom RNN-Cell: 35\n",
    "        \n",
    "    2) Neurons in each layer: \n",
    "        - LSTM: neurons 1. layer 300 < neurons 2. layer 800\n",
    "        - custom RNN-Cell: neurons 1. layer 550 > neurons 2.layer 300\n",
    "        \n",
    "    3) Dropout Layers (DP):\n",
    "        - LSTM: DP rate after 1. hidden layer 0.05 < DP rate after 2. hidden layer 0.45\n",
    "        - custom RNN-Cell: DP rate after 1. hidden layer 0.05 < DP rate after 2. hidden layer 0.3\n",
    "    \n",
    "    4) Weights Regularization:\n",
    "        - LSTM: L2 with 0.002 decay\n",
    "        - custom RNN-Cell: L2 with 0.003 decay\n",
    "        \n",
    "    5) Learning Rate: \n",
    "        - LSTM: 0.002\n",
    "        - custom RNN-Cell: 0.003\n",
    "    \n",
    "    6) Batch Size:\n",
    "        - LSTM: 64\n",
    "        - custom RNN-Cell: 32\n",
    "<br>\n",
    "\n",
    "- **Comparison of the Results with a pre-specified seed and with random/different seeds:**\n",
    "        - LSTM: better performance achieved when different seeds tested\n",
    "        \n",
    "        - custom RNN-Cell: no improvement in the performance when different seeds tested\n",
    "        \n",
    "        - average performance of the models from the 10 runs: \n",
    "          custom RNN-Cell MAPE 4.837 < LSTM MAPE 6.73\n",
    "          \n",
    "        - best performance of each of the models: minimal MAPE achieved\n",
    "          custom RNN-Cell MAPE 2.35266 < LSTM MAPE 5.492\n",
    "\n",
    "<br>\n",
    "\n",
    "- **Conclusion from the Results so far:**\n",
    "        - tuned custom RNN-Cell performs better than tuned LSTM\n",
    "        \n",
    "        - further experiments to be performed in the following way:\n",
    "          set a seed during the trials with Optuna &\n",
    "          once optimal hyperparameters extracted, vary the seed in order\n",
    "          ensure consistent results even when randomization is introduced\n",
    "          \n",
    "\n",
    "    \n",
    "    \n",
    "        \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "createdAt": "2020-04-23T13:50:58Z",
  "createdBy": "i530967",
  "description": "",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  },
  "modifiedAt": "2020-04-23T13:50:58Z",
  "modifiedBy": "i530967",
  "name": "Jupyter Notebook Master Thesis",
  "scenarioId": "19ea932e-735b-4e7c-bc61-ea4c7821bd1d"
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
